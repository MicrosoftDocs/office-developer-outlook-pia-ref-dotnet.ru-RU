<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90ccbcb3fe07f548327e1919c5fa54fecbde32ba" /><Meta Name="ms.sourcegitcommit" Value="9e48edef9d279c87fa2fbd78f150bc92c2332179" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="04/13/2021" /><Meta Name="ms.locfileid" Value="51691751" /></Metadata><TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Это основной интерфейс в компонентном классе COM, который требуется управляемому программному коду для взаимодействия с соответствующим объектом COM. Используйте этот основной интерфейс только в тех случаях, когда метод, который предполагается использовать, имеет такое же имя, как событие объекта COM; в таких случаях для вызова метода приведите к этому интерфейсу, для соединения с событием приведите к интерфейсу последних событий. Иначе используйте интерфейс .NET, который создается но основе компонентного класса COM для доступа к методам, свойствам и событиям объекта COM. Сведения об объекте COM см. в <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> .</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">Тип элемента Outlook для нового элемента. Указывает для <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> создания настраиваемой формы. Может быть одним из следующих констант <b>OlItemType:</b> <b>olAppointmentItem</b>, <b>olContactItem</b>, <b>olJournalItem</b>, <b>olMailItem</b>, <b>olNoteItem</b>, <b>olPostItem</b>, или <b>olTaskItem,</b>или любой допустимый класс сообщения.</param>
        <summary>Создает новый элемент Outlook в <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> коллекции для папки.</summary>
        <returns>Объектное значение, представляю которое представляет новый элемент Outlook.</returns>
        <remarks><para>Если не указано, свойство <b>Type</b> элемента Outlook по умолчанию указывает тип папки или тип родительской папки. <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /></para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.Application" />  объект, который представляет родительское приложение Outlook для объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> констант с указанием класса объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <b>Integer</b> <b>(int</b> in C#), указывающее количество объектов в указанной коллекции. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Строка, которая указывает критерии, которые должен удовлетворять возвращенный объект.</param>
        <summary>Находит и возвращает объект Элемента Outlook, который удовлетворяет данный <paramref name="Filter" /> объект.</summary>
        <returns>Значение Object, представляю которое представляет элемент Outlook, если вызов удался; Возвращает <b>Nothing</b> (null reference (Nothing in Visual Basic) в C#) в случае сбой.</returns>
        <remarks><para>Чтобы использовать поиск индексации контента в <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> коллекции, используйте <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> метод. <b>FindRow</b> возвращает ошибку, если содержит ключевые слова <paramref name="Filter" /> индексации контента. Дополнительные сведения о ключевом слове индексации контента см. в статье Фильтрация элементов <a href="http://go.microsoft.com/fwlink/?LinkId=87947">с помощью ключевых</a> слов запроса</para>
          <para>Метод возвращает ошибку со следующими свойствами в <paramref name="Filter" /> : </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryID2EntryIDEmail3EntryIDEntryIdHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstFirstNoSpaceAutoResolvedWinnerBodyFormernetCodePagePermissionperage</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMeuntNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnHalfOfEntryIDResponseStateSavedSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Создание фильтров для методов поиска и ограничения</para>
          <para>Синтаксис фильтра зависит от типа поля, на который вы фильтруетсяе. </para>
          <para>String (для текстовых полей) </para>
          <para>При поиске текстовых полей можно использовать апостроф (') или двойные кавычка (""), чтобы разграничить значения, которые являются частью фильтра. Например, все следующие строки работают правильно, когда поле имеет тип <b>String</b> <b>(строка</b> в C#): </para>
          <para>sFilter = "[CompanyName] = "Microsoft" </para>
          <para>sFilter = "[CompanyName] = "Microsoft"" </para>
          <para>sFilter = "[CompanyName] = " &amp; Chr(34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>При указании фильтра в запросе Jet или DASL, если вы используете пару одиночных кавычков, чтобы разграничить строку, которая является частью фильтра, а строка содержит еще одну цитату или апостроф, добавьте одну цитату в качестве символа побега перед одной цитатой или апострофом. Используйте аналогичный подход, если для делимитатора строки используется пара двойных кавычков. Если строка содержит двойную кавычка, добавьте двойную кавычка в качестве символа побега перед двойной кавычками.</para>
          <para>Например, в строке фильтра DASL, фильтруемой для свойства <b>Subject,</b> равной слову can't, вся строка фильтра делимитирована парой двойных кавычков, а вложенная строка не может быть разноназначенной парой одиночных кавычков. В этой строке фильтра необходимо выбрать три символа: начальная двойная цитата и конечная двойная цитата для ссылки свойства и апостроф в состоянии значения для слова не http://schemas.microsoft.com/mapi/proptag/0x0037001f может. Применяя соответствующие символы побега, строку фильтра можно выразить следующим образом:</para>
          <para>фильтр = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f = "не может".</para>
          <para>Кроме того, функцию chr(34) можно использовать для представления двойной цитаты (значение символа ASCII — 34), используемой в качестве символа побега. Используя замену chr(34) для символа побега с двойным кавычкам, вы можете выразить последний пример следующим образом:</para>
          <para>фильтр = "@SQL= " &amp; Chr (34) &amp; " http://schemas.microsoft.com/mapi/proptag/0x0037001f _</para>
          <para>    &amp; Chr (34) &amp; " = &amp; "'can'can'"</para>
          <para>Для запросов DASL с операторами ci_startswith или ci_phrasematch <b></b> также требуется избежать одно- и <b>двухзначных символов кавычка.</b> Например, в следующем запросе выполняется запрос на соответствие фразе для не может быть в теме сообщения: </para>
          <para>фильтр = "@SQL=" &amp; Chr(34) &amp; " http://schemas.microsoft.com/mapi/proptag/0x0037001E _</para>
          <para>    &amp; Chr(34) &amp; " ci_phrasematch &amp; "'can'can't"</para>
          <para>Другой пример — строка фильтра DASL, фильтруемая для свойства <b>Subject,</b> равной слову нужный материал, где материал слова заключен двойными кавычками. В этом случае необходимо выбраться из приложенных двойных кавычках следующим образом:</para>
          <para>фильтр = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f = "правильный "материал""</para>
          <para>Другой набор правил побега применяется к ссылке свойства для именных свойств, содержащих пробел, одну цитату, двойную кавычка или процентный символ. Дополнительные сведения см. в ссылке Свойства по Namespace.</para>
          <para>Дата</para>
          <para>Хотя даты и время обычно хранятся в формате Date, методы Поиска и Ограничения требуют преобразования даты и времени в представление строки. Чтобы убедиться, что дата отформатирована так, как ожидает Microsoft Outlook, используйте функцию Format. В следующем примере создается фильтр для поиска всех контактов, измененных после 15 января 1999 г. в 15:30. </para>
          <para>sFilter = "[LastModificationTime] &gt; "" &amp; Format ("1/15/99 3:30pm", "ddddd h:nn AMPM") &amp; """</para>
          <para>Операторы boolean</para>
          <para>Операторы boolean, TRUE/FALSE, YES/NO, ON/OFF и так далее не должны быть преобразованы в строку. Например, чтобы определить, включен ли журнал для контактов, можно использовать этот фильтр: </para>
          <para>sFilter = "[Journal] = True" </para>
          <para>
            <b>Примечание.</b>Если вы используете кавычка в качестве делимитеров с полями Boolean, то пустая строка найдет элементы, поля которых являются false, а все непустые строки найдут элементы, поля которых являются True.</para>
          <para>Ключевые слова (или категории)</para>
          <para>Поле Categories — это ключевые слова типа, предназначенные для удержания нескольких значений. При доступе к нему программным образом поле Categories ведет себя как поле Text, и строка должна точно соответствовать. Значения в текстовой строке разделены запятой и пробелом. Обычно это означает, что методы Поиска и Ограничения нельзя использовать в поле ключевых слов, если оно содержит несколько значений. Например, если у вас есть один контакт в категории "Бизнес" и один контакт в категориях "Бизнес и социальные", вы не можете легко использовать методы Поиска и Ограничения для получения всех элементов, которые находятся в категории "Бизнес". Вместо этого вы можете пройти цикл через все контакты в папке и использовать функцию Instr, чтобы проверить, содержится ли строка "Бизнес" во всем поле ключевых слов. </para>
          <para>
            <b>Примечание.</b>Возможное исключение, если вы ограничиваете поле Categories двумя значениями или низким числом значений. Затем вы можете использовать методы Find and Restrict с логическим оператором OR для получения всех бизнес-контактов. Например (в псевдокоде): "Бизнес" или "Бизнес", "Личный" или "Личный, бизнес". Строки категории не чувствительны к делу.</para>
          <para>Целое число</para>
          <para>В качестве делимитеров можно искать поля Integer с кавычками или без них. В следующих фильтрах будут находиться контакты, созданные с Outlook 2000: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = '92711'"</para>
          <para>Использование переменных в качестве части фильтра</para>
          <para>Как иллюстрирует пример метода Restrict, в составе фильтра можно использовать значения из переменных. В следующем примере кода Visual Basic Майкрософт иллюстрирует синтаксис, использующий переменные в качестве части фильтра. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para> Этот подход использует Chr(34) для разграничить значение: sFilter = "[FullName] = " &amp; Chr (34) &amp; sFullName &amp; Chr(34) </para>
          <para> Этот подход использует двойные кавычка, чтобы разграничить значение: sFilter = "[FullName] = "" &amp; sFullName &amp; """</para>
          <para>Использование логических операторов в качестве части фильтра</para>
          <para>Допустимые логические операторы — AND, OR и NOT. Ниже указаны варианты положения для метода Restrict, поэтому можно указать несколько критериев.  </para>
          <para>ИЛИ: В следующем коде возвращаются все контактные элементы, которые имеют бизнес или личный в качестве своей категории. </para>
          <para>sFilter = "[Categories] = 'Personal' Or [Categories] = 'Business'" </para>
          <para>И. Следующий код извлекает все личные контакты, которые работают в Корпорации Майкрософт. </para>
          <para>sFilter = "[Categories] = "Personal" и [CompanyName] = "Microsoft"" </para>
          <para>НЕТ. В следующем коде извлекались все личные контакты, которые не работают в Microsoft. </para>
          <para>sFilter = "[Categories] = "Personal" And Not ([CompanyName] = "Microsoft')"</para>
          <para>Дополнительные заметки</para>
          <para>Если вы пытаетесь использовать методы Найти или Ограничить с помощью пользовательских полей, поля должны быть определены в папке, в противном случае произойдет ошибка. Операция "содержит" не выполняется. Например, вы не можете использовать Find или Restrict для поиска элементов, которые имеют определенное слово в поле Subject. Вместо этого можно использовать метод AdvancedSearch или выполнить цикл через все элементы в папке и использовать функцию InStr для выполнения поиска в поле. Вы можете использовать метод Restrict для поиска элементов, которые начинаются в определенном диапазоне символов. Например, для поиска всех контактов с фамилией, начиная с буквы M, используйте этот фильтр: </para>
          <para>sFilter = "[LastName] &gt; 'LZZZ' и [LastName] &lt; 'N'"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>После работы метода этот метод находит и возвращает следующий элемент <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  Outlook в указанной коллекции.</summary>
        <returns>Объектное значение, которое представляет следующий элемент Outlook, найденный в коллекции.</returns>
        <remarks><para> Операция поиска начинается с текущего положения, которое соответствует выражению, заранее засвеяемого методом <b>Find.</b></para>
          <para>Метод возвращает объект элемента Outlook в случае успешного вызова; он возвращает <b>Nothing</b> (null reference (Nothing in Visual Basic) в C#), если он не удается.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает первый объект в коллекции.</summary>
        <returns>Значение Object, представляю которое представляет первый объект, содержащийся в коллекции.</returns>
        <remarks><para>Возвращает <b>ничего,</b> если первый объект не существует, например, если в коллекции нет объектов. Чтобы обеспечить правильную работу <b>GetFirst</b>, и методов в большой коллекции, позвоните GetFirst перед вызовом GetNext в этой коллекции и позвоните GetLast перед вызовом <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> <b>GetPrevious</b>. <b></b> <b></b> <b></b> Чтобы убедиться, что вы всегда делаете вызовы в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию, прежде чем входить в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает последний объект в коллекции.</summary>
        <returns>Значение Object, представляю которое представляет последний объект, содержащийся в коллекции.</returns>
        <remarks><para>Он не возвращает <b>ничего,</b> если последний объект не существует, например, если коллекция пуста. Чтобы обеспечить правильную работу , GetLast , и методы в большой коллекции, позвоните GetFirst перед вызовом <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" /> <b></b> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> <b>GetNext</b> <b></b> в этой коллекции, и позвоните <b>GetLast</b> перед вызовом <b>GetPrevious</b>. Чтобы убедиться, что вы всегда делаете вызовы в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию, прежде чем входить в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает следующий объект в коллекции.</summary>
        <returns>Значение Object, которое представляет следующий объект, содержащийся в коллекции.</returns>
        <remarks><para>Он не возвращает <b>ничего,</b> если следующий объект не существует, например, если уже находится в конце коллекции. Чтобы обеспечить правильную работу , GetNext и методов в большой коллекции, позвоните GetFirst перед вызовом GetNext в этой коллекции и позвоните GetLast перед вызовом <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <b></b> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> <b>GetPrevious</b>. <b></b> <b></b> <b></b> Чтобы убедиться, что вы всегда делаете вызовы в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию, прежде чем входить в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает предыдущий объект в коллекции.</summary>
        <returns>Значение Object, которое представляет предыдущий объект, содержащийся в коллекции.</returns>
        <remarks><para>Он не возвращает <b>ничего,</b> если предыдущий объект не существует, например, если он уже находится в начале коллекции. Чтобы обеспечить правильную работу <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" /> методов <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> , и <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" /> <b>GetPrevious</b> в большой коллекции, позвоните <b>в GetFirst</b> перед вызовом <b>GetNext</b> <b></b> в этой коллекции и позвоните в GetLast перед вызовом <b>GetPrevious</b>. Чтобы убедиться, что вы всегда делаете вызовы в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию, прежде чем входить в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <b>boolean</b> <b>(bool</b> в C#), который указывает <b>True,</b> если коллекция должна включать <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> шаблоны повторения. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>Это свойство действует только в том случае, если коллекция <b>Items</b> содержит встречи и не сортироваться любым свойством, кроме как <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> в порядке возрастания. Значение по умолчанию — <b>False</b>. Используйте это свойство, когда необходимо получить все встречи для определенной даты, где повторяющиеся встречи обычно не отображаются, так как они не связаны с какой-либо конкретной датой. Если необходимо сортировать и фильтровать элементы встречи, содержащие повторяющиеся встречи, необходимо сделать это в этом порядке: сортировать элементы в порядке восходящего, заказать <b>IncludeRecurrences</b> to <b>True,</b>а затем отфильтровать элементы. Пример кода, показывающий этот порядок, см. во втором примере ниже. Если в коллекцию входят повторяющиеся встречи без конечной даты, настройка свойства <b>True</b> может привести к бесконечному числу коллекций. Обязательно включай тест для этого в любой цикл. Не следует использовать <b>свойство Count</b> из коллекции <b>Items</b> при итерации коллекции <b>Элементов</b> с <b>свойством IncludeRecurrence,</b> за набором <b>True.</b> Значение <b>Count</b> будет неопределенным.</para>
          <para>
            <b>Внимание.</b>Фильтрация в отсортованный список происшествий приведет к тому, что свойство IncludeRecurrences не будет работать так, как ожидалось. Например, следующая последовательность возвращает все случаи встречи; повторяющиеся и не повторяющиеся: (1) Сортировать свойство Start (2) Установите свойство false (3) call Restrict (например, фильтр).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Либо число индекса объекта, либо значение, используемого для совпадения по умолчанию свойства объекта в коллекции.</param>
        <summary>Возвращает элемент Outlook из коллекции.</summary>
        <value>Значение Объекта, представляю которое представляет указанный объект.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский <b>объект</b> указанного объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Этот объект, элемент или перечисление устарели и не предназначены для использования в коде.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Значение индекса на основе 1 объекта в коллекции.</param>
        <summary>Удаляет объект из коллекции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает свойства, которые кэшировали с помощью <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> метода.</summary>
        <remarks><para>Все свойства доступны после вызова метода <b>ResetColumns.</b> <b>SetColumns</b> необходимо повторно использовать для хранения новых свойств. <b>ResetColumns ничего</b> не делает, <b>если SetColumns</b> не был вызван первым.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Выражение строки фильтра, применяемая. Подробные сведения см. в <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />  методе.</param>
        <summary>Применяет фильтр к коллекции, возвращая новую коллекцию, содержащую все элементы из оригинала, который <see cref="T:Microsoft.Office.Interop.Outlook.Items" />  соответствует фильтру.</summary>
        <returns>Коллекция <b>Items,</b> представляюая элементы из оригинальной коллекции <b>Items,</b> которые соответствуют фильтру.</returns>
        <remarks><para>Этот метод является альтернативой использованию метода или метода для <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />  итерации определенных элементов в коллекции. Методы <b>Find</b> или <b>FindNext</b> быстрее фильтрации при небольшом количестве элементов. Метод <b>Restrict</b> значительно быстрее, если в коллекции большое количество элементов, особенно если ожидается найти только несколько элементов в большой коллекции.</para>
          <para>
            <b>Примечание.</b>Если вы используете поля, определенные пользователем, <b></b> как часть пункта <b>Найти</b> или Ограничить, поля, определенные пользователем, должны существовать в папке. В противном случае код создает ошибку, указывав, что поле неизвестно. Поле можно добавить в папку, отобразив выбор поля и нажав кнопку New.</para>
          <para>Этот метод нельзя использовать и приведет к ошибке со следующими свойствами:</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryID2EntryIDEmail3EntryIDEntryIdHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstFirstNoSpaceAutoResolvedWinnerBodyFormernetCodePagePermissionperage</description>
              <description>LastFirstNoSpaceCompanyLastFirstSpaceOnlyLastFirstSpaceOnlyCompanyLastFirstNoSpaceAndSuffixMeuntNetMeetingAliasNetMeetingAutoStartNetMeetingOrganizerAliasNetMeetingServerNetMeetingTypeRecurrenceStateReplyRecipientsReceivedByEntryIDRecevedOnHalfOfEntryIDResponseStateSavedSubmittedVotingOptionsDownloadStateIsConflictMeetingWorkspaceURL</description>
            </item>
          </list>
          <para>Создание фильтров для методов поиска и ограничения</para>
          <para>Синтаксис фильтра зависит от типа поля, на который вы фильтруетсяе. </para>
          <para>String (для текстовых полей) </para>
          <para>При поиске текстовых полей можно использовать либо апостроф ('), либо двойные кавычка (""), чтобы разграничить значения, которые являются частью фильтра. Например, все следующие строки работают правильно, когда поле имеет тип <b>String</b> <b>(строка</b> в C#): </para>
          <para>sFilter = "[CompanyName] = "Microsoft" </para>
          <para>sFilter = "[CompanyName] = "Microsoft"" </para>
          <para>sFilter = "[CompanyName] = " &amp; Chr(34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>При указании фильтра в запросе Jet или DASL, если вы используете пару одиночных кавычков, чтобы разграничить строку, которая является частью фильтра, а строка содержит еще одну цитату или апостроф, добавьте одну цитату в качестве символа побега перед одной цитатой или апострофом. Используйте аналогичный подход, если для делимитатора строки используется пара двойных кавычков. Если строка содержит двойную кавычка, добавьте двойную кавычка в качестве символа побега перед двойной кавычками.</para>
          <para>Например, в строке фильтра DASL, фильтруемой для свойства <b>Subject,</b> равной слову can't, вся строка фильтра делимитирована парой двойных кавычков, а вложенная строка не может быть разноназначенной парой одиночных кавычков. В этой строке фильтра необходимо выбрать три символа: начальная двойная цитата и конечная двойная цитата для ссылки свойства и апостроф в состоянии значения для слова не http://schemas.microsoft.com/mapi/proptag/0x0037001f может. Применяя соответствующие символы побега, строку фильтра можно выразить следующим образом:</para>
          <para>фильтр = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f = "не может".</para>
          <para>Кроме того, функцию chr(34) можно использовать для представления двойной цитаты (значение символа ASCII — 34), используемой в качестве символа побега. Используя замену chr(34) для символа побега с двойным кавычкам, вы можете выразить последний пример следующим образом:</para>
          <para>фильтр = "@SQL= " &amp; Chr (34) &amp; " http://schemas.microsoft.com/mapi/proptag/0x0037001f _</para>
          <para>    &amp; Chr (34) &amp; " = &amp; "'can'can'"</para>
          <para>Для запросов DASL с операторами ci_startswith или ci_phrasematch <b></b> также требуется избежать одно- и <b>двухзначных символов кавычка.</b> Например, в следующем запросе выполняется запрос на соответствие фразе для не может быть в теме сообщения: </para>
          <para>фильтр = "@SQL=" &amp; Chr(34) &amp; " http://schemas.microsoft.com/mapi/proptag/0x0037001E _</para>
          <para>    &amp; Chr(34) &amp; " ci_phrasematch &amp; "'can'can't"</para>
          <para>Другой пример — строка фильтра DASL, фильтруемая для свойства <b>Subject,</b> равной слову нужный материал, где материал слова заключен двойными кавычками. В этом случае необходимо выбраться из приложенных двойных кавычках следующим образом:</para>
          <para>фильтр = "@SQL="" http://schemas.microsoft.com/mapi/proptag/0x0037001f = "правильный "материал""</para>
          <para>Другой набор правил побега применяется к ссылке свойства для именных свойств, содержащих пробел, одну цитату, двойную кавычка или процентный символ. Дополнительные сведения см. в ссылке Свойства по Namespace.</para>
          <para>Дата</para>
          <para>Хотя даты и время обычно хранятся в формате Date, методы <b>Поиска</b> и Ограничения требуют преобразования даты и времени в представление строки. <b></b> Чтобы убедиться, что дата отформатирована так, как ожидает Microsoft Outlook, используйте <b>функцию Format.</b> В следующем примере создается фильтр для поиска всех контактов, измененных после 15 января 1999 г. в 15:30. </para>
          <para>sFilter = "[LastModificationTime] &gt; "" &amp; Format ("1/15/99 3:30pm", "ddddd h:nn AMPM") &amp; """</para>
          <para>Операторы boolean</para>
          <para>Операторы boolean, TRUE/FALSE, YES/NO, ON/OFF и так далее не должны быть преобразованы в строку. Например, чтобы определить, включен ли журнал для контактов, можно использовать этот фильтр: </para>
          <para>sFilter = "[Journal] = True" </para>
          <para>
            <b>Примечание.</b>Если вы используете кавычка в качестве делимитеров с полями <b></b> <b>Boolean,</b> то пустая строка найдет элементы, поля которых являются false, а все непустые строки найдут элементы, поля которых true <b>.</b> </para>
          <para>Ключевые слова (или категории)</para>
          <para>Поле Categories — это ключевые слова типа, предназначенные для удержания нескольких значений. При доступе к нему программным образом поле Categories ведет себя как поле Text, и строка должна точно соответствовать. Значения в текстовой строке разделены запятой и пробелом. Обычно это означает, что методы <b></b> <b>Поиска</b> и Ограничения нельзя использовать в поле ключевых слов, если оно содержит несколько значений. Например, если у вас есть один контакт в категории "Бизнес" и один контакт <b></b> в <b></b> категориях "Бизнес и социальные", вы не можете легко использовать методы Поиска и Ограничения для получения всех элементов, которые находятся в категории "Бизнес". Вместо этого вы можете пройти цикл через все контакты в папке и использовать функцию <b>Instr,</b> чтобы проверить, содержится ли строка "Бизнес" во всем поле ключевых слов. </para>
          <para>
            <b>Примечание.</b>Возможное исключение, если вы ограничиваете поле Categories двумя значениями или низким числом значений. Затем вы можете использовать методы <b>Find</b> and <b>Restrict</b> с логическим оператором OR для получения всех бизнес-контактов. Например (в псевдокоде): "Бизнес" или "Бизнес", "Личный" или "Личный, бизнес". Строки категории не чувствительны к делу. </para>
          <para>Целое число</para>
          <para>В качестве делимитеров можно искать поля <b>Integer</b> с кавычками или без них. В следующих фильтрах будут находиться контакты, созданные с помощью Outlook 2000: </para>
          <para>sFilter = "[OutlookInternalVersion] = 92711" </para>
          <para>sFilter = "[OutlookInternalVersion] = '92711'"</para>
          <para>Использование переменных в качестве части фильтра</para>
          <para>Как <b></b> иллюстрирует пример метода Restrict, в составе фильтра можно использовать значения из переменных. В следующем примере кода Visual Basic Майкрософт иллюстрирует синтаксис, использующий переменные в качестве части фильтра. </para>
          <para>sFullName = "Dan Wilson" </para>
          <para>В этом подходе используется Chr(34), чтобы разграничить значение. </para>
          <para>sFilter = "[FullName] = " &amp; Chr(34) &amp; sFullName &amp; Chr (34) </para>
          <para>Этот подход использует двойные кавычка, чтобы разграничить значение. </para>
          <para>sFilter = "[FullName] = """ &amp; sFullName &amp; """</para>
          <para>Использование логических операторов в качестве части фильтра</para>
          <para>Допустимые логические операторы — AND, OR и NOT. Ниже указаны варианты пункта для метода <b>Restrict,</b> чтобы можно было указать несколько критериев.  </para>
          <para>ИЛИ: В следующем коде возвращаются все контактные элементы, которые имеют бизнес или личный в качестве своей категории. </para>
          <para>sFilter = "[Categories] = 'Personal' Or [Categories] = 'Business'" </para>
          <para>И. Следующий код извлекает все личные контакты, которые работают в Корпорации Майкрософт. </para>
          <para>sFilter = "[Categories] = "Personal" и [CompanyName] = "Microsoft"" </para>
          <para>НЕТ. В следующем коде извлекались все личные контакты, которые не работают в Microsoft. </para>
          <para>sFilter = "[Categories] = "Personal" And Not ([CompanyName] = "Microsoft')"</para>
          <para>Дополнительные заметки</para>
          <para>Если вы пытаетесь использовать <b></b> методы <b>Найти</b> или Ограничить с помощью пользовательских полей, поля должны быть определены в папке, в противном случае произойдет ошибка. Операция "содержит" не выполняется. Например, вы не можете использовать <b>Find</b> или <b>Restrict</b> для поиска элементов, которые имеют определенное слово в поле Subject. Вместо этого можно использовать метод или выполнить цикл через все элементы в папке и использовать функцию InStr для выполнения поиска <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> в поле. <b></b> Вы можете использовать метод <b>Restrict</b> для поиска элементов, которые начинаются в определенном диапазоне символов. Например, для поиска всех контактов с фамилией, начиная с буквы M, используйте этот фильтр: </para>
          <para>sFilter = "[LastName] &gt; 'LZZZ' и [LastName] &lt; 'N'"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" />  для текущего сеанса. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Свойство <b>Session</b> и метод можно использовать взаимозаменяемо для получения объекта <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> <b>NameSpace</b> для текущего сеанса. Оба члена служат одной и той же цели. Например, следующие пары заявлений выполняют ту же функцию:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">Строка с именами свойств кэша. Имена свойств делимитированы запятой в этой строке.</param>
        <summary>Кэшет некоторых свойств для чрезвычайно быстрого доступа к этим определенным свойствам элемента в коллекции.</summary>
        <remarks><para>Метод <b>SetColumns</b> полезен для итерации в <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> коллекции. Если этот метод не используется, Microsoft Outlook должна открыть каждый элемент для доступа к свойству. С помощью <b>метода SetColumns</b> Outlook проверяет только те свойства, которые кэшировали, и обеспечивает быстрый доступ только для чтения к этим свойствам.</para>
          <para>Применяя метод <b>SetColumns</b> для определенных свойств коллекции, вы не можете прочитать другие свойства этой коллекции; свойства, которые не кэшировали, возвращаются пустыми. Вы также не можете написать ни к какову из свойств этой коллекции. Кроме того, если требуется быстрое чтение и быстрый доступ к набору элементов, используйте <see cref="T:Microsoft.Office.Interop.Outlook.Table" /> объект.</para>
          <para>
            <b>SetColumns</b> нельзя использовать и приведет к ошибке с любым свойством, возвращая объект. Его нельзя использовать со следующими свойствами:</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Текст</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Категории</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Класс</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Компании</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Saved</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Sent</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Submitted</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para>Свойство <b>ConversationIndex</b> нельзя кэшовать с помощью <b>метода SetColumns.</b> Однако это свойство не приведет к ошибке, как другие свойства, перечисленные выше.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">Имя свойства для сортировки, которое может быть заключено в скобки, например "[CompanyName]". Свойства, определенные пользователем, которые содержат пробелы, должны быть заключены в скобки. Не может быть свойством, определенным пользователем, ключевых слов типа и не может быть многомерным свойством, например категорией. Для свойств, определенных пользователем, свойство должно существовать в коллекции <b>UserDefinedProperties,</b> для которой представлен объект, содержащий <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" /> <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> элементы.</param>
        <param name="Descending"><b>True</b> для сортировки в порядке убывания. Значение по умолчанию <b>false</b> (восходящее).</param>
        <summary>Сортировать коллекцию элементов по указанному свойству. После завершения этого метода индекс для коллекции сбрасывается до 1.</summary>
        <remarks><para>
            <b>Сортировка</b> влияет только на порядок элементов в коллекции. Это не влияет на порядок элементов в представлении проводника.</para>
          <para>
            <b>Сортировка</b> не может использоваться и приведет к ошибке, если параметр <paramref name="property" /> является одним из следующих свойств:                </para>
          <list type="table">
            <item>
              <description>
                <b>Категории</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Класс</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Сохранено</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Отправлено</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
