<Type Name="_Items" FullName="Microsoft.Office.Interop.Outlook._Items">
  <Metadata><Meta Name="ms.openlocfilehash" Value="90ccbcb3fe07f548327e1919c5fa54fecbde32ba" /><Meta Name="ms.sourcegitcommit" Value="8bffa304e2953ca61fa94459dd08997552262640" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="04/05/2019" /><Meta Name="ms.locfileid" Value="31479564" /></Metadata><TypeSignature Language="C#" Value="public interface _Items : System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Items implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Items" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Items&#xA;Implements IEnumerable" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Items : System::Collections::IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("00063041-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Это основной интерфейс в компонентном классе COM, который требуется управляемому программному коду для взаимодействия с соответствующим объектом COM. Используйте этот основной интерфейс только в тех случаях, когда метод, который предполагается использовать, имеет такое же имя, как событие объекта COM; в таких случаях для вызова метода приведите к этому интерфейсу, для соединения с событием приведите к интерфейсу последних событий. Иначе используйте интерфейс .NET, который создается но основе компонентного класса COM для доступа к методам, свойствам и событиям объекта COM. Сведения о COM-объекте приведены в разделе <see cref="T:Microsoft.Office.Interop.Outlook.Items" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public object Add (object Type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Add([in]object Type) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (Optional Type As Object) As Object" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(95)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Type" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Type">Тип элемента Outlook для нового элемента. <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.MessageClass" /> Задает создание настраиваемых форм. Может быть одной из следующих констант <b>OlItemType</b> : <b>олаппоинтментитем</b>, <b>олконтактитем</b>, <b>олжаурналитем</b>, <b>олмаилитем</b>, <b>олнотеитем</b>, <b>олпоститем</b>или <b>олтаскитем</b>, или любое допустимое сообщение классе.</param>
        <summary>Создает новый элемент Outlook в <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> коллекции для папки.</summary>
        <returns>Значение объекта, представляющее новый элемент Outlook.</returns>
        <remarks><para>Если значение не указано, свойство <b>Type</b> элемента Outlook по умолчанию имеет тип папки или <see cref="T:Microsoft.Office.Interop.Outlook.MailItem" /> не является типом родительской папки.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.Application" /> объект, представляющий родительское приложение Outlook для объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> константу, указывающую класс объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(80)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <b>типа Integer</b> (<b>int</b> в C#), указывающее количество объектов в указанной коллекции. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public object Find (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Find([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (Filter As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Find(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(98)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Строка, указывающая критерии, которым должен удовлетворять возвращаемый объект.</param>
        <summary>Ищет и возвращает объект элемента Outlook, который соответствует заданному <paramref name="Filter" />значению.</summary>
        <returns>Значение объекта, представляющее элемент Outlook при успешном вызове; Возвращает значение <b>Nothing</b> (пустая ссылка (Nothing в Visual Basic) в C#) в случае сбоя.</returns>
        <remarks><para>Чтобы использовать поиск по индексированию содержимого <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> в коллекции, используйте <see cref="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" /> метод. При вызове метода <b>FindRow</b> возвращается <paramref name="Filter" /> сообщение об ошибке, если содержит ключевые слова индексирования содержимого. Дополнительные сведения о ключевых словах индексирования содержимого приведены в статье <a href="http://go.microsoft.com/fwlink/?LinkId=87947">Фильтрация элементов с помощью ключевых слов запроса</a></para>
          <para>Метод возвратит ошибку со следующими свойствами в <paramref name="Filter" />: </para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePage Права</description>
              <description>ЛастфирстноспацекомпаниластфирстспацеонлиластфирстспацеонликомпаниластфирстноспацеандсуффиксмемберкаунтнетмитингалиаснетмитингаутостартнетмитингорганизералиаснетмитингсервернетмитингтиперекурренцестатереплиреЦипиентсрецеиведбентридрецеведонбехалфофентридреспонсестате Саведсентсубмиттедвотингоптионсдовнлоадстатеисконфликтмитингворкспацеурл</description>
            </item>
          </list>
          <para>Создание фильтров для методов Find и reStrict</para>
          <para>Синтаксис фильтра зависит от типа поля, по которому выполняется фильтрация. </para>
          <para>Строка (для текстовых полей) </para>
          <para>При поиске текстовых полей можно использовать апостроф (') или двойные кавычки (""), чтобы разделить значения, которые являются частью фильтра. Например, все приведенные ниже строки работают правильно, если поле имеет тип <b>String</b> (<b>строка</b> в C#). </para>
          <para>Сфилтер = "[CompanyName] = ' Microsoft '" </para>
          <para>Сфилтер = "[CompanyName] =" "Microsoft" "" </para>
          <para>Сфилтер = "[CompanyName] =" &amp; Chr (34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>При указании фильтра в запросе Jet или DASL, если вы используете парные одинарные кавычки, чтобы разделить строку, которая является частью фильтра, а строка содержит другую одинарную кавычку или апостроф, добавьте одну кавычку в качестве escape-знака перед одинарной кавычкой или апострофом. Аналогичный подход используется, если вы разделяюте строку с помощью парных двойных кавычек. Если строка содержит двойные кавычки, добавьте двойные кавычки в качестве escape-знака перед двойным предложением.</para>
          <para>Например, в строке фильтра DASL, в которой фильтрация свойства <b>subject</b> равна слову "не удается", вся строка фильтра отделяется друг от друга двойными кавычками, а внедренная строка не может быть ограничена с помощью парных одинарных кавычек. В этой строке фильтра необходимо использовать три символа: Начальная двойная кавычка и закрывающая двойная кавычка для ссылки на свойство http://schemas.microsoft.com/mapi/proptag/0x0037001f, а также апостроф в условии значения для слова не может быть. При применении соответствующих escape-символов можно выразить строку фильтра следующим образом:</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "" = "не может '"</para>
          <para>Кроме того, вы можете использовать функцию Chr (34) для представления двойных кавычек (чей символ ASCII имеет значение 34), используемого в качестве escape-символа. Используя подстановку Chr (34) для символа escape-знака двойной кавычки, вы можете выразить последний пример следующим образом:</para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp;Chr (34) &amp; "=" &amp; "" не может быть "</para>
          <para>Для запросов DASL с операторами <b>Ци_стартсвис</b> или <b>Ци_фрасематч</b> также необходим escape-символ одинарной и двойной кавычки. Например, следующий запрос выполняет запрос фразы для поиска в теме сообщения: </para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp;Chr (34) &amp; "Ци_фрасематч" &amp; "" не может быть ""</para>
          <para>Другой пример — это строка фильтра DASL, которая фильтрует для свойства <b>subject</b> значение, равное словам справа, в которых слова заключены в двойные кавычки. В этом случае необходимо заключить в кавычки следующие двойные кавычки:</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "", "" материалы "" ""</para>
          <para>Другой набор правил отстановки применяются к ссылке на свойство для именованных свойств, которые содержат пробелы, одинарные кавычки, двойные кавычки или знаки процентов. Дополнительные сведения: ссылки на свойства по пространству имен.</para>
          <para>Дата</para>
          <para>Хотя даты и время, как правило, хранятся в формате даты, методы Find и reStrict требуют, чтобы дата и время были преобразованы в строковое представление. Чтобы убедиться, что дата отформатирована как ожидается в Microsoft Outlook, используйте функцию Format. В следующем примере создается фильтр для поиска всех контактов, которые были изменены после 15 января 1999 г. в 3:30 P.M.. </para>
          <para>сфилтер = "[LastModificationTime] &gt; " " &amp; формат (" 1/15/99 3:30pm "," ддддд х:НН ампм ") &amp; " "</para>
          <para>Логические операторы</para>
          <para>Логические операторы, TRUE/FALSE, YES/NO, ON/on и т. д. не должны быть преобразованы в строку. Например, чтобы определить, включено ли ведение журнала для контактов, можно использовать следующий фильтр: </para>
          <para>Сфилтер = "[Журнал] = true" </para>
          <para>
            <b>Note</b>: Если вы используете кавычки в качестве разделителей с логическими полями, то пустая строка будет искать элементы, поля которых имеют значение false, а все непустые строки будут искать элементы, поля которых имеют значение true.</para>
          <para>Ключевые слова (или категории)</para>
          <para>Поле категории имеет тип ключевых слов, предназначенный для хранения нескольких значений. При обращении к нему программным способом поле Categories имеет вид текстового поля, а строка должна полностью совпадать. Значения в текстовой строке разделяются запятыми и пробелом. Обычно это означает, что нельзя использовать методы Find и reStrict для поля ключевых слов, если оно содержит более одного значения. Например, если у вас есть один контакт в категории "Бизнес" и один контакт в категории "предприятие" и "социальные", вы не можете легко использовать методы Find и reStrict для получения всех элементов в категории "Бизнес". Вместо этого можно перебрать все контакты в папке и использовать функцию InStr, чтобы проверить, находится ли строка "Бизнес" в рамках всего поля ключевых слов. </para>
          <para>
            <b>Примечание</b>. возможные исключения: при ограничении поля категории двумя или небольшое количество значений. Затем вы можете использовать методы Find и reStrict с логическим оператором OR для получения всех бизнес-контактов. Например, в псевдокоде: "Бизнес" или "бизнес, личное" или "личное, Бизнес". В строках категорий регистр не учитывается.</para>
          <para>Целое</para>
          <para>Вы можете выполнять поиск целочисленных полей с помощью кавычек или без них в качестве разделителей. Следующие фильтры будут искать контакты, созданные с помощью Outlook 2000: </para>
          <para>Сфилтер = "[OutlookInternalVersion] = 92711" </para>
          <para>Сфилтер = "[OutlookInternalVersion] = ' 92711 '"</para>
          <para>Использование переменных в составе фильтра</para>
          <para>Как показано в примере метода reStrict, можно использовать значения из переменных в качестве части фильтра. Приведенный ниже пример кода Microsoft Visual Basic иллюстрирует синтаксис, в котором используются переменные в качестве части фильтра. </para>
          <para>Сфуллнаме = "" Wilson) " </para>
          <para> Этот подход использует Chr (34) для разграничения значений: Сфилтер = "[FullName] =" &amp; Chr (34) &amp; сфуллнаме &amp; Chr (34) </para>
          <para> Этот подход использует двойные кавычки, чтобы разделять значение: Сфилтер = "[FullName] =" &amp; " &amp; " сфуллнаме "" ""</para>
          <para>Использование логических операторов в качестве части фильтра</para>
          <para>Допустимые логические операторы: AND, OR и NOT. Ниже приведены варианты предложения для метода reStrict, чтобы можно было указать несколько условий.  </para>
          <para>ИЛИ: следующий код возвращает все элементы контакта, которые имеют категории "Бизнес" или "персональный". </para>
          <para>Сфилтер = "[Categories] = ' личное ' или [Categories] = ' Бизнес '" </para>
          <para>А: следующий код получает все личные контакты, которые работают в корпорации Майкрософт. </para>
          <para>Сфилтер = "[Categories] = ' личное ' и [CompanyName] = ' Microsoft '" </para>
          <para>NOT: следующий код получает все личные контакты, которые не работают в корпорации Майкрософт. </para>
          <para>Сфилтер = "[Categories] = ' персональный ', а не ([CompanyName] = ' Microsoft ')</para>
          <para>Дополнительные примечания</para>
          <para>Если вы пытаетесь использовать методы Find или reStrict с пользовательскими полями, эти поля должны быть определены в папке, в противном случае возникнет ошибка. Невозможно выполнить операцию "содержит". Например, нельзя использовать Find или reStrict для поиска элементов, содержащих определенное слово в поле Тема. Вместо этого можно использовать метод AdvancedSearch, или можно перебрать все элементы в папке и использовать функцию InStr для выполнения поиска в поле. Можно использовать метод reStrict для поиска элементов, начинающихся в пределах определенного диапазона символов. Например, чтобы найти все контакты с фамилией, начинающейся с буквы M, используйте следующий фильтр: </para>
          <para>Сфилтер = "[LastName] &gt; " Лззз "и [LastName] &lt; ' N '"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="FindNext">
      <MemberSignature Language="C#" Value="public object FindNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object FindNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.FindNext" />
      <MemberSignature Language="VB.NET" Value="Public Function FindNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(99)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>После выполнения <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> метода этот метод находит и возвращает следующий элемент Outlook в указанной коллекции.</summary>
        <returns>Значение объекта, представляющее следующий элемент Outlook, найденный в коллекции.</returns>
        <remarks><para> Операция поиска начинается с текущей позиции, которая соответствует выражению, ранее заданному с помощью метода <b>Find</b> .</para>
          <para>Метод возвращает объект элемента Outlook, если вызов выполнен успешно; Он возвращает <b>Nothing</b> (пустая ссылка (Nothing в Visual Basic) в C#) в случае сбоя.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetFirst">
      <MemberSignature Language="C#" Value="public object GetFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetFirst() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFirst () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(86)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает первый объект в коллекции.</summary>
        <returns>Значение объекта, представляющее первый объект, содержащийся в коллекции.</returns>
        <remarks><para>Возвращает <b>значение Nothing</b> , если первый объект не существует, например, если в коллекции нет объектов. Чтобы обеспечить правильную работу методов <b></b>GetNext, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" /> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, и <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> методов в большом семействе, <b>сначала</b> вызовите метод GetNext перед вызовом метода GetNext для этой коллекции и <b></b> перед вызовом метода <b>GetNext</b> вызовите метод GetNext <b> </b>. Чтобы обеспечить постоянное выполнение вызовов в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию перед входом в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLast">
      <MemberSignature Language="C#" Value="public object GetLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetLast() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLast () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(88)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает последний объект в коллекции.</summary>
        <returns>Значение объекта, представляющее последний объект, содержащийся в коллекции.</returns>
        <remarks><para>Он возвращает <b>Nothing</b> , если не существует последнего объекта, например, если коллекция пуста. Чтобы обеспечить правильную работу методов <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <b></b> <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />методов и <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> методов в большом семействе, <b>сначала</b> вызовите метод GetNext перед вызовом метода GetNext для этой коллекции, а затем <b></b> вызовите метод GetNext перед вызовом метода <b>GetNext</b> <b> </b>. Чтобы обеспечить постоянное выполнение вызовов в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию перед входом в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNext">
      <MemberSignature Language="C#" Value="public object GetNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetNext() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNext () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(87)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает следующий объект в коллекции.</summary>
        <returns>Значение объекта, представляющее следующий объект, содержащийся в коллекции.</returns>
        <remarks><para>Он возвращает <b>Nothing</b> , если следующий объект не существует, например, если он уже расположен в конце коллекции. Чтобы обеспечить правильную работу методов <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <b>GetNext</b>и <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" /> методов в большом семействе, <b>сначала</b> вызовите метод GetNext перед вызовом метода <b>GetNext</b> для этой коллекции, а <b></b> затем вызовите метод GetNext перед вызовом метода <b>Previous </b>. Чтобы обеспечить постоянное выполнение вызовов в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию перед входом в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrevious">
      <MemberSignature Language="C#" Value="public object GetPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetPrevious() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.GetPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPrevious () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(89)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает предыдущий объект в коллекции.</summary>
        <returns>Значение объекта, представляющее предыдущий объект, содержащийся в коллекции.</returns>
        <remarks><para>Он возвращает <b>значение Nothing</b> , если не существует предыдущего объекта, например, если он уже расположен в начале коллекции. Чтобы обеспечить правильную работу методов <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetFirst" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetLast" />, <see cref="M:Microsoft.Office.Interop.Outlook._Items.GetNext" />, и <b>Previous</b> в большом семействе, <b>сначала</b> вызовите метод GetNext перед вызовом метода <b>GetNext</b> для этой коллекции, а затем вызовите метод GetNext перед вызовом <b></b> <b>метода-Last. Previous</b>. Чтобы обеспечить постоянное выполнение вызовов в одной коллекции, создайте явную переменную, которая ссылается на эту коллекцию перед входом в цикл.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IncludeRecurrences">
      <MemberSignature Language="C#" Value="public bool IncludeRecurrences { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IncludeRecurrences" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.IncludeRecurrences" />
      <MemberSignature Language="VB.NET" Value="Public Property IncludeRecurrences As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IncludeRecurrences { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(206)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <b>логическое</b> значение (<b>bool</b> в C#), которое указывает <b>true</b> , <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> если коллекция должна включать шаблоны повторения. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>Это свойство действует только в том случае, если коллекция <b>Items</b> содержит встречи и не отсортирована ни с одним свойством, отличным от <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.Start" /> порядка по возрастанию. Значение по умолчанию — <b>False</b>. Используйте это свойство, если требуется получить все встречи для определенной даты, в результате чего повторяющиеся встречи обычно не будут отображаться, так как они не связаны с какой-либо определенной датой. Если необходимо сортировать и фильтровать элементы встреч, содержащие повторяющиеся встречи, необходимо сделать это в следующем порядке: сортировать элементы по возрастанию, задать для <b>IncludeRecurrences</b> <b>значение true</b>и затем отфильтровать элементы. Пример кода, в котором показан этот заказ, представлен во втором примере ниже. Если коллекция включает повторяющиеся встречи без даты окончания, то установка для свойства значения <b>true</b> может привести к неограниченному количеству элементов в коллекции. Не забудьте включить тест для этого в любом цикле. Не следует использовать свойство <b>Count</b> коллекции <b>Items</b> при итерации коллекции <b>Items</b> со свойством <b>инклудерекурренце</b> , равным <b>true</b>. Значение <b>Count</b> будет иметь неопределенное значение.</para>
          <para>
            <b>Внимание!</b>фильтрация по отсортированному списку экземпляров приводит к тому, что свойство IncludeRecurrences не будет работать должным образом. Например, следующая последовательность вернет все экземпляры встречи; повторяющиеся и неповторяющиеся: (1) Сортировка по начальному свойству (2) задайте для свойства значение false (3) ограничение вызовов (то есть фильтр).</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public object this[object Index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(Index As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ Index); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Index">Номер индекса объекта или значение, используемое для сравнения со свойством по умолчанию объекта в коллекции.</param>
        <summary>Возвращает элемент Outlook из коллекции.</summary>
        <value>Значение объекта, представляющее указанный объект.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский <b>объект</b> указанного объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RawTable">
      <MemberSignature Language="C#" Value="public object RawTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object RawTable" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.RawTable" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RawTable As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ RawTable { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(90)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.TypeLibFunc(64)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Этот объект, элемент или перечисление устарели и не предназначены для использования в коде.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (int Index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Remove([in]int32 Index) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (Index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(int Index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(84)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Index">Значение индекса объекта в коллекции (от 1).</param>
        <summary>Удаляет объект из коллекции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetColumns">
      <MemberSignature Language="C#" Value="public void ResetColumns ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResetColumns() runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.ResetColumns" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetColumns ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetColumns();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(93)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет свойства, кэшированные с помощью <see cref="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" /> метода.</summary>
        <remarks><para>Все свойства доступны после вызова метода <b>ResetColumns</b> . <b>Метода SetColumns</b> следует повторно использовать для хранения новых свойств. <b>ResetColumns</b> не выполняет никаких действий, если <b>метода SetColumns</b> не вызывался первым.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Restrict">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Items Restrict (string Filter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class Microsoft.Office.Interop.Outlook.Items Restrict([in]string Filter) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Restrict(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Restrict (Filter As String) As Items" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Microsoft::Office::Interop::Outlook::Items ^ Restrict(System::String ^ Filter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(100)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Items</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Filter" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Filter">Выражение строки фильтра, которое необходимо применить. Дополнительные сведения см. в <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> описании метода.</param>
        <summary>ПриМеняет фильтр к <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> коллекции, возвращая новую коллекцию, содержащую все элементы из исходного объекта, которые совпадают с фильтром.</summary>
        <returns>Коллекция <b>Items</b> , представляющая элементы из коллекции исходных <b>элементов</b> , которые отвечают условиям фильтра.</returns>
        <remarks><para>Этот метод является альтернативой использованию <see cref="M:Microsoft.Office.Interop.Outlook._Items.Find(System.String)" /> метода или <see cref="M:Microsoft.Office.Interop.Outlook._Items.FindNext" /> метода для итерации по определенным элементам в коллекции. Методы <b>Find</b> или <b>FindNext</b> быстрее, чем фильтрация при наличии небольшого количества элементов. Метод <b>restrict</b> работает значительно быстрее, если в коллекции имеется большое количество элементов, особенно если ожидается, что будет найден только несколько элементов в большой коллекции.</para>
          <para>
            <b>Примечание</b>. Если вы используете пользовательские поля в предложении <b>Find</b> или Restrict, пользовательские <b></b> поля должны находиться в папке. В противном случае код создаст ошибку, сообщающую о неизвестном поле. Вы можете добавить поле в папку, выполнив выбор поля и нажав кнопку Создать.</para>
          <para>Этот метод невозможно использовать и приведет к ошибке со следующими свойствами:</para>
          <list type="table">
            <item>
              <description>BodyCategoriesChildrenClassCompaniesCompanyLastFirstNoSpaceCompanyLastFirstSpaceOnlyContactNamesContactsConversationIndexDLNameEmail1EntryIDEmail2EntryIDEmail3EntryIDEntryIDHTMLBodyIsOnlineMeetingLastFirstAndSuffixLastFirstNoSpaceAutoResolvedWinnerBodyFormatInternetCodePage Права</description>
              <description>ЛастфирстноспацекомпаниластфирстспацеонлиластфирстспацеонликомпаниластфирстноспацеандсуффиксмемберкаунтнетмитингалиаснетмитингаутостартнетмитингорганизералиаснетмитингсервернетмитингтиперекурренцестатереплиреЦипиентсрецеиведбентридрецеведонбехалфофентридреспонсестате Саведсентсубмиттедвотингоптионсдовнлоадстатеисконфликтмитингворкспацеурл</description>
            </item>
          </list>
          <para>Создание фильтров для методов Find и reStrict</para>
          <para>Синтаксис фильтра зависит от типа поля, по которому выполняется фильтрация. </para>
          <para>Строка (для текстовых полей) </para>
          <para>При поиске текстовых полей можно использовать апостроф (') или двойные кавычки (""), чтобы разделить значения, которые являются частью фильтра. Например, все приведенные ниже строки работают правильно, если поле имеет тип <b>String</b> (<b>строка</b> в C#). </para>
          <para>Сфилтер = "[CompanyName] = ' Microsoft '" </para>
          <para>Сфилтер = "[CompanyName] =" "Microsoft" "" </para>
          <para>Сфилтер = "[CompanyName] =" &amp; Chr (34) &amp; "Microsoft" &amp; Chr (34)</para>
          <para>При указании фильтра в запросе Jet или DASL, если вы используете парные одинарные кавычки, чтобы разделить строку, которая является частью фильтра, а строка содержит другую одинарную кавычку или апостроф, добавьте одну кавычку в качестве escape-знака перед одинарной кавычкой или апострофом. Аналогичный подход используется, если вы разделяюте строку с помощью парных двойных кавычек. Если строка содержит двойные кавычки, добавьте двойные кавычки в качестве escape-знака перед двойным предложением.</para>
          <para>Например, в строке фильтра DASL, в которой фильтрация свойства <b>subject</b> равна слову "не удается", вся строка фильтра отделяется друг от друга двойными кавычками, а внедренная строка не может быть ограничена с помощью парных одинарных кавычек. В этой строке фильтра необходимо использовать три символа: Начальная двойная кавычка и закрывающая двойная кавычка для ссылки на свойство http://schemas.microsoft.com/mapi/proptag/0x0037001f, а также апостроф в условии значения для слова не может быть. При применении соответствующих escape-символов можно выразить строку фильтра следующим образом:</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "" = "не может '"</para>
          <para>Кроме того, вы можете использовать функцию Chr (34) для представления двойных кавычек (чей символ ASCII имеет значение 34), используемого в качестве escape-символа. Используя подстановку Chr (34) для символа escape-знака двойной кавычки, вы можете выразить последний пример следующим образом:</para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001f" _</para>
          <para>    &amp;Chr (34) &amp; "=" &amp; "" не может быть "</para>
          <para>Для запросов DASL с операторами <b>Ци_стартсвис</b> или <b>Ци_фрасематч</b> также необходим escape-символ одинарной и двойной кавычки. Например, следующий запрос выполняет запрос фразы для поиска в теме сообщения: </para>
          <para>Filter = "@SQL=" &amp; Chr (34) &amp; "http://schemas.microsoft.com/mapi/proptag/0x0037001E" _</para>
          <para>    &amp;Chr (34) &amp; "Ци_фрасематч" &amp; "" не может быть ""</para>
          <para>Другой пример — это строка фильтра DASL, которая фильтрует для свойства <b>subject</b> значение, равное словам справа, в которых слова заключены в двойные кавычки. В этом случае необходимо заключить в кавычки следующие двойные кавычки:</para>
          <para>Filter = "@SQL=" "http://schemas.microsoft.com/mapi/proptag/0x0037001f" "", "" материалы "" ""</para>
          <para>Другой набор правил отстановки применяются к ссылке на свойство для именованных свойств, которые содержат пробелы, одинарные кавычки, двойные кавычки или знаки процентов. Дополнительные сведения: ссылки на свойства по пространству имен.</para>
          <para>Дата</para>
          <para>Хотя даты и время, как правило, хранятся в формате даты, методы <b>Find</b> и Restrict требуют, чтобы дата и время были преобразованы в строковое представление. <b></b> Чтобы убедиться, что дата отформатирована как ожидается в Microsoft Outlook, используйте функцию <b>Format</b> . В следующем примере создается фильтр для поиска всех контактов, которые были изменены после 15 января 1999 г. в 3:30 P.M.. </para>
          <para>сфилтер = "[LastModificationTime] &gt; " " &amp; формат (" 1/15/99 3:30pm "," ддддд х:НН ампм ") &amp; " "</para>
          <para>Логические операторы</para>
          <para>Логические операторы, TRUE/FALSE, YES/NO, ON/on и т. д. не должны быть преобразованы в строку. Например, чтобы определить, включено ли ведение журнала для контактов, можно использовать следующий фильтр: </para>
          <para>Сфилтер = "[Журнал] = true" </para>
          <para>
            <b>Note</b>: Если вы используете кавычки в качестве разделителей с <b>логическими</b> полями, то пустая строка будет искать элементы, поля которых имеют <b>значение false</b> , а все непустые строки будут искать элементы, поля которых имеют <b>значение true</b>. </para>
          <para>Ключевые слова (или категории)</para>
          <para>Поле категории имеет тип ключевых слов, предназначенный для хранения нескольких значений. При обращении к нему программным способом поле Categories имеет вид текстового поля, а строка должна полностью совпадать. Значения в текстовой строке разделяются запятыми и пробелом. Обычно это означает, что нельзя использовать методы <b>Find</b> и <b>restrict</b> для поля ключевых слов, если оно содержит более одного значения. Например, если у вас есть один контакт в категории "Бизнес" и один контакт в категории "предприятие" и "социальные", вы не можете легко использовать методы <b>Find</b> и Restrict для получения всех элементов в категории "Бизнес". <b></b> Вместо этого можно перебрать все контакты в папке и использовать функцию <b>InStr</b> , чтобы проверить, находится ли строка "Бизнес" в рамках всего поля ключевых слов. </para>
          <para>
            <b>Примечание</b>. возможные исключения: при ограничении поля категории двумя или небольшое количество значений. Затем вы можете использовать методы <b>Find</b> и <b>restrict</b> с логическим оператором OR для получения всех бизнес-контактов. Например, в псевдокоде: "Бизнес" или "бизнес, личное" или "личное, Бизнес". В строках категорий регистр не учитывается. </para>
          <para>Целое</para>
          <para>Вы можете выполнять поиск <b>целочисленных</b> полей с помощью или без кавычек в качестве разделителей. Следующие фильтры помогут найти контакты, созданные с помощью Outlook 2000: </para>
          <para>Сфилтер = "[OutlookInternalVersion] = 92711" </para>
          <para>Сфилтер = "[OutlookInternalVersion] = ' 92711 '"</para>
          <para>Использование переменных в составе фильтра</para>
          <para>Как показано <b></b> в примере метода restrict, можно использовать значения из переменных в качестве части фильтра. Приведенный ниже пример кода Microsoft Visual Basic иллюстрирует синтаксис, в котором используются переменные в качестве части фильтра. </para>
          <para>Сфуллнаме = "" Wilson) " </para>
          <para>' Этот подход использует Chr (34) для разграничения значений. </para>
          <para>Сфилтер = "[FullName] =" &amp; Chr (34) &amp; сфуллнаме &amp; Chr (34) </para>
          <para>' Для разграничения значения в этом подходе используются двойные кавычки. </para>
          <para>Сфилтер = "[FullName] =" "" &amp; сфуллнаме &amp; "" ""</para>
          <para>Использование логических операторов в качестве части фильтра</para>
          <para>Допустимые логические операторы: AND, OR и NOT. Ниже приведены варианты предложения для метода reStrict, <b></b> чтобы можно было указать несколько условий.  </para>
          <para>ИЛИ: следующий код возвращает все элементы контакта, которые имеют категории "Бизнес" или "персональный". </para>
          <para>Сфилтер = "[Categories] = ' личное ' или [Categories] = ' Бизнес '" </para>
          <para>А: следующий код получает все личные контакты, которые работают в корпорации Майкрософт. </para>
          <para>Сфилтер = "[Categories] = ' личное ' и [CompanyName] = ' Microsoft '" </para>
          <para>NOT: следующий код получает все личные контакты, которые не работают в корпорации Майкрософт. </para>
          <para>Сфилтер = "[Categories] = ' персональный ', а не ([CompanyName] = ' Microsoft ')</para>
          <para>Дополнительные примечания</para>
          <para>Если вы пытаетесь использовать методы <b>Find</b> или Restrict <b></b> с пользовательскими полями, эти поля должны быть определены в папке, в противном случае возникнет ошибка. Невозможно выполнить операцию "содержит". Например, нельзя использовать <b>Find</b> или Restrict <b></b> для поиска элементов, содержащих определенное слово в поле Тема. Вместо этого можно использовать <see cref="M:Microsoft.Office.Interop.Outlook._Application.AdvancedSearch(System.String,System.Object,System.Object,System.Object)" /> метод, или можно перебрать все элементы в папке и использовать функцию <b>InStr</b> для выполнения поиска в поле. Можно использовать метод <b>restrict</b> для поиска элементов, начинающихся в пределах определенного диапазона символов. Например, чтобы найти все контакты с фамилией, начинающейся с буквы M, используйте следующий фильтр: </para>
          <para>Сфилтер = "[LastName] &gt; " Лззз "и [LastName] &lt; ' N '"</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Items.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" /> объект для текущего сеанса. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Свойство <b>Session</b> и <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> метод можно использовать в качестве взаимозаменяемого для получения объекта <b>пространства имен</b> для текущего сеанса. Оба участника выполняют одну и ту же задачу. Например, следующие пары операторов выполняют одну и ту же функцию:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="SetColumns">
      <MemberSignature Language="C#" Value="public void SetColumns (string Columns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetColumns([in]string Columns) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.SetColumns(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetColumns (Columns As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetColumns(System::String ^ Columns);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(92)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Columns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Columns">Строка, содержащая имена свойств для кэширования. Имена свойств разделяются запятыми в этой строке.</param>
        <summary>Кэширует определенные свойства для чрезвычайно быстрого доступа к этим определенным свойствам элемента в коллекции.</summary>
        <remarks><para>Метод <b>метода SetColumns</b> полезен для итерации по <see cref="T:Microsoft.Office.Interop.Outlook.Items" /> коллекции. Если этот метод не используется, Microsoft Outlook должен открыть каждый элемент, чтобы получить доступ к свойству. С помощью метода <b>метода SetColumns</b> Outlook проверяет кэшированные свойства и предоставляет быстрый доступ только для чтения к этим свойствам.</para>
          <para>После применения метода <b>метода SetColumns</b> к определенным свойствам коллекции невозможно считать другие свойства этой коллекции; свойства, которые не кэшируются, возвращаются пустыми. Невозможно выполнить запись в любое свойство этой коллекции. Кроме того, если вам необходим быстрый доступ к набору элементов для чтения и записи, используйте <see cref="T:Microsoft.Office.Interop.Outlook.Table" /> объект.</para>
          <para>
            <b>Метода SetColumns</b> не может использоваться, и приведет к ошибке со свойством, возвращающим объект. Его нельзя использовать со следующими свойствами:</para>
          <list type="table">
            <item>
              <description>AutoResolvedWinner</description>
              <description>InternetCodePage</description>
            </item>
            <item>
              <description>Основной текст</description>
              <description>MeetingWorkspaceURL</description>
            </item>
            <item>
              <description>BodyFormat</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>Категории</description>
              <description>ReceivedByEntryID</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>ReceivedOnBehalfOfEntryID</description>
            </item>
            <item>
              <description>Class</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>Companies</description>
              <description>ReplyRecipients</description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>DownloadState</description>
              <description>Saved</description>
            </item>
            <item>
              <description>EntryID</description>
              <description>Sent</description>
            </item>
            <item>
              <description>HTMLBody</description>
              <description>Submitted</description>
            </item>
            <item>
              <description>IsConflict</description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._MailItem.VotingOptions" />
              </description>
            </item>
          </list>
          <para>Свойство <b>ConversationIndex</b> не может кэшироваться с помощью метода <b>метода SetColumns</b> . Однако это свойство не приведет к ошибке, как и другие свойства, перечисленные выше.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (string Property, object Descending);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Sort([in]string Property, [in]object Descending) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Items.Sort(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Sort (Property As String, Optional Descending As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(97)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Property" Type="System.String" />
        <Parameter Name="Descending" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Property">Имя свойства, по которому выполняется сортировка, которое может быть заключено в квадратные скобки, например "[CompanyName]". Определяемые пользователем свойства, содержащие пробелы, должны быть заключены в квадратные скобки. Возможно, не является пользовательским свойством ключевых слов Type и не может быть многозначным свойством, например категорией. Для свойств, определяемых пользователем, свойство должно существовать в коллекции <b>UserDefinedProperties</b> для <see cref="P:Microsoft.Office.Interop.Outlook._Items.Parent" />, которое представляет <see cref="T:Microsoft.Office.Interop.Outlook.Folder" /> объект, содержащий элементы.</param>
        <param name="Descending"><b>Значение true</b> , чтобы сортировать в убывающем порядке. Значение по умолчанию — <b>false</b> (по возрастанию).</param>
        <summary>Сортирует коллекцию элементов по указанному свойству. После завершения этого метода индекс для коллекции сбрасывается в 1.</summary>
        <remarks><para>
            <b>Sort</b> влияет только на порядок элементов в коллекции. Он не влияет на порядок элементов в представлении проводника.</para>
          <para>
            <b></b> Невозможно использовать сортировку и приведет к ошибке, если <paramref name="property" /> параметр имеет одно из следующих свойств:                </para>
          <list type="table">
            <item>
              <description>
                <b>Категории</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnly" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.Children" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstSpaceOnlyCompany" />
              </description>
            </item>
            <item>
              <description>
                <b>Класс</b>
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.MemberCount" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstNoSpace" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.NetMeetingAlias" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.CompanyLastFirstSpaceOnly" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._AppointmentItem.RecurrenceState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._DistListItem.DLName" />
              </description>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._TaskItem.ResponseState" />
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstAndSuffix" />
              </description>
              <description>
                <b>Saved</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpace" />
              </description>
              <description>
                <b>Sent</b>
              </description>
            </item>
            <item>
              <description>
                <see cref="P:Microsoft.Office.Interop.Outlook._ContactItem.LastFirstNoSpaceCompany" />
              </description>
              <description />
            </item>
          </list>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
