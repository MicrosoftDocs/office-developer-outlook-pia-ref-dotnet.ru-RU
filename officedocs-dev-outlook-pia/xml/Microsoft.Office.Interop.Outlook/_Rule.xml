<Type Name="_Rule" FullName="Microsoft.Office.Interop.Outlook._Rule">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0fc7984ff84a0eea00858aa8ce56abf24313ff68" /><Meta Name="ms.sourcegitcommit" Value="372abf58b21f4fab503d106f0e8c8a2ac45f9332" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/12/2019" /><Meta Name="ms.locfileid" Value="27902798" /></Metadata><TypeSignature Language="C#" Value="public interface _Rule" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Rule" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Rule" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Rule" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Rule" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("000630CD-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Это основной интерфейс в компонентном классе COM, который требуется управляемому программному коду для взаимодействия с соответствующим объектом COM. Используйте этот основной интерфейс только в тех случаях, когда метод, который предполагается использовать, имеет такое же имя, как событие объекта COM; в таких случаях для вызова метода приведите к этому интерфейсу, для соединения с событием приведите к интерфейсу последних событий. Иначе используйте интерфейс .NET, который создается но основе компонентного класса COM для доступа к методам, свойствам и событиям объекта COM. Сведения о COM-объекте приведены в разделе <see cref="T:Microsoft.Office.Interop.Outlook.Rule" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Actions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleActions Actions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleActions Actions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Actions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Actions As RuleActions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleActions ^ Actions { Microsoft::Office::Interop::Outlook::RuleActions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64272)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64272)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleActions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:Microsoft.Office.Interop.Outlook.RuleActions" /> Collection, который представляет все доступные действия правил для правила. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Можно перечислять и включать правила с любым действием, которое поддерживает мастер правил и оповещений, но вы можете программным способом создавать правила, содержащие только наиболее часто используемые действия правил, а не какие действия правил, поддерживаемые мастером правил и оповещений. Дополнительные сведения о поддержке действий правил приведены в разделе <a href="http://go.microsoft.com/fwlink/?LinkId=87797">Определение действий правил</a></para>
          <para>С помощью свойства <b>Actions</b> каждое правило связано с объектом <b>RuleActions</b> . Коллекция <b>RuleActions</b> является фиксированным объектом, поэтому вы не можете добавлять и удалять элементы из этой коллекции. Действия правил, включенные в правиле, будут иметь включенное действие правила в коллекции <b>RuleActions</b> . Действия правила, которые не включены в правиле, будут иметь действие правила в этой коллекции, <see cref="P:Microsoft.Office.Interop.Outlook._RuleAction.Enabled" /> свойству которого присвоено значение <b>false</b>. Действия правил, которые не поддерживаются во время создания программного правила, можно перечислять только в коллекции <b>RuleActions</b> для существующего правила, но так как коллекция <b>RuleActions</b> является фиксированной, вы не можете создать правило и добавить такое действие в связанную коллекцию <b>RuleActions</b> .</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.Application" /> объект, представляющий родительское приложение Outlook для объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> константу, указывающую класс объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Conditions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleConditions Conditions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleConditions Conditions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Conditions As RuleConditions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleConditions ^ Conditions { Microsoft::Office::Interop::Outlook::RuleConditions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64297)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64297)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleConditions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" /> Collection, который представляет все доступные условия для правила. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Условие для правила указывает условие, при котором правило должно быть применено. И <b>условия</b> , и <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" /> свойства используют один пул условий и возвращают соответствующий объект коллекции <b>RuleConditions</b> .</para>
          <para>Программно можно перечислять и включать правила с любым условием правила, которое поддерживает мастер правил и оповещений, но вы можете создавать правила, которые содержат только наиболее часто используемые условия правил, а не условия правил, поддерживаемые мастером правил и оповещений. Дополнительные сведения о поддержке условий правил приведены в статье <a href="http://go.microsoft.com/fwlink/?LinkId=87803">Определение условий правил</a></para>
          <para>С помощью свойства <b>Condition</b> каждое правило связано с объектом <b>RuleConditions</b> . Коллекция <b>RuleConditions</b> является фиксированным объектом, поэтому вы не можете добавлять и удалять элементы из этой коллекции. Условия правил, включенные в правиле, будут иметь включенное условие правила в коллекции <b>RuleConditions</b> . Условия правила, которые не включены в правиле, будут иметь условие правила в этой коллекции, <see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" /> свойству которого присвоено значение <b>false</b>. Условия для правил, которые не поддерживаются во время создания программного правила, можно перечислять только в коллекции <b>RuleConditions</b> для существующего правила, но так как коллекция <b>RuleConditions</b> является фиксированной, вы не можете создать правило и добавить такое условие в связанную коллекцию <b>RuleConditions</b> .</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает <b>логическое</b> значение (<b>bool</b> в C#), определяющее, следует ли применять правило. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>Задание свойства <b>Enabled</b> для правила не гарантирует, что правило будет включено. Правило включается только после <see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" /> успешного выполнения.</para>
          <para>С помощью <b>правила. Enabled</b> и <b>Rules. Save</b> применяет правило согласованно и сохраняет правила за пределами текущего сеанса. При включении правила (которое было успешно сохранено) гарантируется, что правило будет применено. Если это правило локального клиента, правило будет применяться при запуске Outlook, и если правило относится к серверу, оно будет применено независимо от того, работает ли Outlook. Если не включить правило, правило будет определено, но оно не будет применено. Однако можно использовать <see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" /> для применения правила в качестве одноразовой операции независимо от того, включено ли правило.  </para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Exceptions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleConditions Exceptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleConditions Exceptions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exceptions As RuleConditions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleConditions ^ Exceptions { Microsoft::Office::Interop::Outlook::RuleConditions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64307)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64307)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleConditions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" /> Collection, который представляет все доступные условия исключения правила для правила. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Условие исключения для правила указывает условие, при котором правило не должно применяться. Оба свойства <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" /> и <b>исключения</b> используют один пул условий и возвращают соответствующий объект коллекции <b>RuleConditions</b> .</para>
          <para>Можно перечислять и включать правила с любым условием исключения правила, поддерживаемым мастером правил и оповещений, но можно программным путем создать правила, содержащие только наиболее часто используемые правила исключений, а не любое условие исключения правила, поддерживаемое мастером правил и оповещений. Дополнительные сведения о поддержке условий правил приведены в статье <a href="http://go.microsoft.com/fwlink/?LinkId=87803">Определение условий правил</a></para>
          <para>С помощью свойства <b>Condition</b> каждое правило связано с объектом <b>RuleConditions</b> . Коллекция <b>RuleConditions</b> является фиксированным объектом, поэтому вы не можете добавлять и удалять элементы из этой коллекции. Для правил исключений, включенных в правило, будет включено условие исключения правила в коллекции <b>RuleConditions</b> . Условия правила исключения, которые не включены в правиле, будут иметь условие исключения правила в этой коллекции, <see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" /> свойству которого присвоено значение <b>false</b>. Условия исключений для правил, которые не поддерживаются во время создания программного правила, можно перечислить только в коллекции <b>RuleConditions</b> для существующего правила, но так как коллекция <b>RuleConditions</b> является фиксированной, невозможно создать правило и добавить такое условие исключения в связанную коллекцию <b>RuleConditions</b> .</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object ShowProgress, object Folder, object IncludeSubfolders, object RuleExecuteOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute([in]object ShowProgress, [in]object Folder, [in]object IncludeSubfolders, [in]object RuleExecuteOption) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (Optional ShowProgress As Object, Optional Folder As Object, Optional IncludeSubfolders As Object, Optional RuleExecuteOption As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64270)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ShowProgress" Type="System.Object" />
        <Parameter Name="Folder" Type="System.Object" />
        <Parameter Name="IncludeSubfolders" Type="System.Object" />
        <Parameter Name="RuleExecuteOption" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ShowProgress"><b>Значение true</b> для отображения диалогового окна хода выполнения при выполнении правила, <b>значение false</b> для запуска правила без отображения диалогового окна.</param>
        <param name="Folder">Представляет папку, в которую будет применено правило.</param>
        <param name="IncludeSubfolders"><b>True</b> , чтобы правило применялось к вложенным папкам папки, указанной параметром Folder; <b>False</b> , чтобы правило применялось только к этой папке, но не вложенным папкам.</param>
        <param name="RuleExecuteOption">Указывает, следует ли применять правило к чтению, непрочтению или ко всем сообщениям в папке или папкам, заданным параметрами Folder и Инклудесубфолдерс.</param>
        <summary>Применение правила в качестве одноразовой операции.</summary>
        <remarks><para>Используйте <see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" /> для применения правила в качестве одноразовой операции независимо от того, является ли <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" /> оно <b>истинным</b>. Используйте <b>rule. Enabled</b> , а <see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" /> затем для согласованного применения правила и сохранения правил за пределами текущего сеанса.</para>
          <para>Параметры метода <b>EXECUTE</b> являются необязательными. Если параметры не указаны, правило будет применяться ко всем сообщениям в папке "Входящие", но не к вложенным папкам папки "Входящие". По умолчанию для дополнительных аргументов используются следующие значения: </para>
          <list type="table">
            <item>
              <description>Параметр</description>
              <description>Значение по умолчанию</description>
            </item>
            <item>
              <description>ShowProgress</description>
              <description>False</description>
            </item>
            <item>
              <description>Folder</description>
              <description>Inbox</description>
            </item>
            <item>
              <description>IncludeSubfolders</description>
              <description>False</description>
            </item>
            <item>
              <description>RuleExecuteOption</description>
              <description>
                <b>OlRuleExecuteOption. Олруликсекутеаллмессажес</b>
              </description>
            </item>
          </list>
          <para>Если <paramref name="ShowProgress" /> параметр имеет <b>значение true</b> и пользователь отменяет диалоговое окно хода выполнения, то выполнение правила отменяется таким же образом, как если бы пользователь отменил выполнение правила с помощью мастера правил и оповещений. Execute возвращает сообщение об ошибке, когда пользователь отменяет диалоговое окно хода выполнения.</para>
          <para>Если вы планируете отображать пользовательский интерфейс выполнения, а не диалоговое окно Ход выполнения, следует иметь в виду, что события, указывающие, когда выполнение правила начинается и останавливаются, не отображаются. </para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecutionOrder">
      <MemberSignature Language="C#" Value="public int ExecutionOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExecutionOrder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.ExecutionOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property ExecutionOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExecutionOrder { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение <b>типа Integer</b> (<b>int</b> в C#), которое указывает порядок выполнения правила среди других правил в <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> коллекции. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>
            <b>Ексекутионордер</b> напрямую сопоставляются с числовым значением <paramref name="Index" /> in. <see cref="P:Microsoft.Office.Interop.Outlook._Rules.Item(System.Object)" /> Например, Rules. Item (1) представляет правило с <b>ексекутионордер</b> по 1, Rules. Item (2) представляет правило с <b>Ексекутионордер</b> , а Rules. Item (Rules. Count) представляет правило с параметром <b>ексекутионордер</b> <see cref="P:Microsoft.Office.Interop.Outlook._Rules.Count" />.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalRule">
      <MemberSignature Language="C#" Value="public bool IsLocalRule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalRule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.IsLocalRule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocalRule As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocalRule { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64269)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64269)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <b>логическое значение</b> (<b>bool</b> в C#), которое указывает, выполняется ли правило как клиентское правило. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Правило на стороне клиента выполняется только при запуске Outlook. Если <b>IsLocalRule</b> имеет <b>значение false</b>, то правило выполняется как правило на стороне сервера.</para>
          <para>Если у вас есть учетная запись электронной почты Microsoft Exchange Server, сервер может применить к ним серверные правила, даже если Outlook не работает. Правила должны быть настроены для применения к сообщениям, когда они доставляются в папку "Входящие" на сервере, а правила должны быть доступны для завершения на сервере. Например, правило не может выполняться до завершения на сервере, если действие указывает на необходимость печати сообщения. Если правило не может быть применено на сервере, оно применяется при запуске Outlook.</para>
          <para>Если коллекция Rules в хранилище содержит правила как сервера, так и на стороне клиента, сначала применяются правила на стороне сервера, а затем правила на стороне клиента.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает <b>строку</b> (<b>строка</b> в C#), представляющую имя правила. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>
            <b>Name</b> — это свойство по умолчанию и индексатор для правила в объекте <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> Collection. Он соответствует <b>PidTagRuleMsgName</b> (0x65EC001E).</para>
          <para>Имена правил не уникальны для разных правил в одной коллекции.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский <b>объект</b> указанного объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Родительским <see cref="T:Microsoft.Office.Interop.Outlook.Rule" /> объектом объекта является <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> объект.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="RuleType">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlRuleType RuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlRuleType RuleType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.RuleType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleType As OlRuleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlRuleType RuleType { Microsoft::Office::Interop::Outlook::OlRuleType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64268)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64268)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlRuleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает константу из <see cref="T:Microsoft.Office.Interop.Outlook.OlRuleType" /> перечисления, которая указывает, применяется ли правило к отправляемым или принимаемым сообщениям. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" /> объект для текущего сеанса. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Свойство <b>Session</b> и <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> метод можно использовать в качестве взаимозаменяемого для получения объекта <b>пространства имен</b> для текущего сеанса. Оба участника выполняют одну и ту же задачу. Например, следующие пары операторов выполняют одну и ту же функцию:</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
