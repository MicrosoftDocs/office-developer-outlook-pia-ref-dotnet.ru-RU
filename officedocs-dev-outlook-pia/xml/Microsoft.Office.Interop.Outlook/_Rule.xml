<Type Name="_Rule" FullName="Microsoft.Office.Interop.Outlook._Rule">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0fc7984ff84a0eea00858aa8ce56abf24313ff68" /><Meta Name="ms.sourcegitcommit" Value="372abf58b21f4fab503d106f0e8c8a2ac45f9332" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="01/12/2019" /><Meta Name="ms.locfileid" Value="27902798" /></Metadata><TypeSignature Language="C#" Value="public interface _Rule" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract _Rule" />
  <TypeSignature Language="DocId" Value="T:Microsoft.Office.Interop.Outlook._Rule" />
  <TypeSignature Language="VB.NET" Value="Public Interface _Rule" />
  <TypeSignature Language="C++ CLI" Value="public interface class _Rule" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
    <AssemblyVersion>15.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.Guid("000630CD-0000-0000-C000-000000000046")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.TypeLibType(4160)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Это основной интерфейс в компонентном классе COM, необходимые для управляемого кода для взаимодействия с соответствующим COM-объектом. Этот основной интерфейс используется только в том случае, если метод, который будет использоваться совместно совпадает с именем событие COM-объектом; в этом случае преобразовывается этот интерфейс для вызова метода и приведены последние интерфейс события для подключения к событию. В противном случае используется интерфейс .NET, который является производным от компонентного класса COM для доступа к методы, свойства и события COM-объектом. Сведения о COM-объектом, в разделе <see cref="T:Microsoft.Office.Interop.Outlook.Rule" />.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="Actions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleActions Actions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleActions Actions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Actions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Actions As RuleActions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleActions ^ Actions { Microsoft::Office::Interop::Outlook::RuleActions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64272)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64272)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleActions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.RuleActions" /> коллекцию, содержащую объект, представляющий все доступные rule actions для правила. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Можно перечислить и включения правил с действиями правила, правила и оповещения мастер поддержки, но можно программно создавать правила, которые имеют только действия наиболее часто используемые правил, а не любые действия правила, правила и оповещения мастер поддерживает. Дополнительные сведения о поддержке действие правила можно <a href="http://go.microsoft.com/fwlink/?LinkId=87797">Указать действия правила</a></para>
          <para>Через свойство <b>действия</b> каждого правила связан с объектом <b>RuleActions</b> . Коллекции <b>RuleActions</b> — это фиксированный объект - невозможно добавление или удаление элементов из коллекции. Действия правил, которые включены в правиле будут иметь действие включено правило в коллекции <b>RuleActions</b> . Действия, которые не включены в правило будет иметь действие правила в этой коллекции, которая содержит правило <see cref="P:Microsoft.Office.Interop.Outlook._RuleAction.Enabled" /> свойства задано значение <b>False</b>. Действия правил, которые не поддерживаются при создании программный правила можно перечислить только в коллекции <b>RuleActions</b> для существующего правила, но поскольку фиксированные коллекции <b>RuleActions</b> не удается создать правило и добавьте такое действие для связанные коллекции <b>RuleActions</b> .</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.Application Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.Application Application" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Application" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Application As Application" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::Application ^ Application { Microsoft::Office::Interop::Outlook::Application ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61440)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.Application</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.Application" /> объект, представляющий родительский приложение Outlook для объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Class">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlObjectClass Class { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlObjectClass Class" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Class" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Class As OlObjectClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlObjectClass Class { Microsoft::Office::Interop::Outlook::OlObjectClass get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlObjectClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.OlObjectClass" /> константа, класс объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Conditions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleConditions Conditions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleConditions Conditions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Conditions As RuleConditions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleConditions ^ Conditions { Microsoft::Office::Interop::Outlook::RuleConditions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64297)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64297)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleConditions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" /> коллекцию, содержащую объект, представляющий доступных условий для правила. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Условие для правила указывает условие, в котором необходимо применять правило. Оба <b>условия</b> и <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" /> свойства совместно использовать тот же самый пул условий и возврата соответствующего объекта коллекции <b>RuleConditions</b> .</para>
          <para>Программным путем перечисления и включения правил с помощью любого условие правила, правила и оповещения мастер поддержки, но можно создать правила, которые имеют только наиболее часто используемые правила условия и не все условия правила, который поддерживает правила и оповещения мастера. Дополнительные сведения о поддержке условие правила можно <a href="http://go.microsoft.com/fwlink/?LinkId=87803">Указание условия правила</a></para>
          <para>С помощью свойства <b>условия</b> в каждом правиле связан с объект <b>RuleConditions</b> . Коллекции <b>RuleConditions</b> — это фиксированный объект - невозможно добавление или удаление элементов из коллекции. Условия для правил, которые включены в правиле будут иметь условие включено правило в коллекции <b>RuleConditions</b> . Условия, которые не включены в правило будет иметь условие для правила в этой коллекции, которая содержит правило <see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" /> свойства задано значение <b>False</b>. Условия для правил, которые не поддерживаются при создании программный правила можно перечислить только в коллекции <b>RuleConditions</b> для существующего правила, но поскольку фиксированные коллекции <b>RuleConditions</b> не удается создать правило и добавьте такие условие в соответствующую коллекцию <b>RuleConditions</b> .</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(103)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или устанавливает <b>логическое</b> значение (<b>bool</b> в C#), который определяет, является ли правило применяется. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>Задание для свойства <b>Enabled</b> правило не гарантирует, что правило будет включено. Правило будет включено только после того, как <see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" /> выполнена успешно.</para>
          <para>С помощью <b>Rule.Enabled</b> и <b>Rules.Save</b> правило применяется постоянно и сохраняет правил текущего сеанса. Включение правила (который был сохранен успешно) гарантирует, что правило будет применяться. Если это правило локальных клиентов, правило будет применяться при с Outlook, а также если правило правила на стороне сервера, он применяется независимо от того, работает ли Outlook. Если не включить правило, затем определяется правило, но не применяются. Тем не менее, можно использовать <see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" /> Чтобы применить правило как одноразовых операция независимо от того, включен ли правило.  </para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Exceptions">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.RuleConditions Exceptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.RuleConditions Exceptions" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Exceptions" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Exceptions As RuleConditions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::RuleConditions ^ Exceptions { Microsoft::Office::Interop::Outlook::RuleConditions ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64307)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64307)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.RuleConditions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.RuleConditions" /> коллекцию, содержащую объект, представляющий все доступные правила условия исключений для правила. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Условие исключения для правила указывает условие, под которой правило не применяется. Как <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Conditions" /> и свойства <b>исключения</b> совместно использовать тот же самый пул условий и возврата соответствующего объекта коллекции <b>RuleConditions</b> .</para>
          <para>Можно перечислить и включения правил с помощью любого условие правила исключения, правила и оповещения мастера поддерживают, но можно программно создавать правила, которые имеют только наиболее часто используемые условия правила исключение, и не все правила исключения условием, что Правила и оповещения мастер поддерживает. Дополнительные сведения о поддержке условие правила можно <a href="http://go.microsoft.com/fwlink/?LinkId=87803">Указание условия правила</a></para>
          <para>С помощью свойства <b>условия</b> в каждом правиле связан с объект <b>RuleConditions</b> . Коллекции <b>RuleConditions</b> — это фиксированный объект - невозможно добавление или удаление элементов из коллекции. Условия исключений правила, для которых включено в правиле будут иметь включенное условие исключения в коллекции <b>RuleConditions</b> . Условия исключений, которые не включены в правиле будут иметь условие для правила исключения в этой коллекции, которая содержит правило <see cref="P:Microsoft.Office.Interop.Outlook._RuleCondition.Enabled" /> свойства задано значение <b>False</b>. Условия исключений правила, которые не поддерживаются при создании программный правила можно перечислить только в коллекции <b>RuleConditions</b> для существующего правила, но поскольку фиксированные коллекции <b>RuleConditions</b> не удается создать правило и Добавьте такой условие исключения связанной коллекции <b>RuleConditions</b> .</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Execute">
      <MemberSignature Language="C#" Value="public void Execute (object ShowProgress, object Folder, object IncludeSubfolders, object RuleExecuteOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Execute([in]object ShowProgress, [in]object Folder, [in]object IncludeSubfolders, [in]object RuleExecuteOption) runtime managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Execute (Optional ShowProgress As Object, Optional Folder As Object, Optional IncludeSubfolders As Object, Optional RuleExecuteOption As Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64270)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ShowProgress" Type="System.Object" />
        <Parameter Name="Folder" Type="System.Object" />
        <Parameter Name="IncludeSubfolders" Type="System.Object" />
        <Parameter Name="RuleExecuteOption" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="ShowProgress"><b>Значение true,</b> чтобы открыть диалоговое окно хода выполнения при выполнении правила, и <b>значение False</b> для запуска правила без отображения диалогового окна.</param>
        <param name="Folder">Представляет папку, где будет применяться это правило.</param>
        <param name="IncludeSubfolders"><b>Значение true,</b> Чтобы применить правило вложенные папки, указанное с помощью параметра папки; <b>Значение false,</b> Чтобы правило применяется только к этой папке, но не ее вложенных папок.</param>
        <param name="RuleExecuteOption">Представляет ли применить правило для чтения, непрочитанные или все сообщения в папку или папки, указанном с помощью папки и IncludeSubfolders.</param>
        <summary>Правило применяется как одноразовых операция.</summary>
        <remarks><para>Использование <see cref="M:Microsoft.Office.Interop.Outlook._Rule.Execute(System.Object,System.Object,System.Object,System.Object)" /> Чтобы применить правило как одноразовых операция независимо от того, требуется ли <see cref="P:Microsoft.Office.Interop.Outlook._Rule.Enabled" /> имеет <b>значение True</b>. Используйте <b>Rule.Enabled</b> и затем <see cref="M:Microsoft.Office.Interop.Outlook._Rules.Save(System.Object)" /> Если вы хотите применить правило постоянно и сохранение правил текущего сеанса.</para>
          <para>Параметры для метода <b>Execute</b> являются необязательными. Если не указать параметры, правило будет применяться ко всем сообщениям в папке "Входящие", но не вложенные папки «Входящие». Значения по умолчанию для необязательных аргументов, как показано ниже: </para>
          <list type="table">
            <item>
              <description>Параметр</description>
              <description>Значение по умолчанию</description>
            </item>
            <item>
              <description>ShowProgress</description>
              <description>False</description>
            </item>
            <item>
              <description>Folder</description>
              <description>Inbox</description>
            </item>
            <item>
              <description>IncludeSubfolders</description>
              <description>False</description>
            </item>
            <item>
              <description>RuleExecuteOption</description>
              <description>
                <b>OlRuleExecuteOption.olRuleExecuteAllMessages</b>
              </description>
            </item>
          </list>
          <para>Если <paramref name="ShowProgress" /> имеет <b>значение True</b> и отменяет пользователя, в диалоговом окне Ход выполнения правила отменяется точно так же, как если отменена пользователем правила выполнения правила и оповещения мастера. Выполнение возвращает ошибку, если пользователь отменил диалогового окна хода выполнения.</para>
          <para>Если вы планируете отображать пользовательский интерфейс настраиваемой хода выполнения вместо с помощью диалогового окна хода выполнения, следует иметь в виду, что нет событий, которые указывают время запуска и остановки выполнения правила. </para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecutionOrder">
      <MemberSignature Language="C#" Value="public int ExecutionOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExecutionOrder" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.ExecutionOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property ExecutionOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExecutionOrder { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(64267)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение типа <b>Integer</b> (<b>int</b> в C#), указывает порядок выполнения правила среди других правил в <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> семейства сайтов. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>
            <b>ExecutionOrder</b> непосредственно сопоставляются с числовое значение <paramref name="Index" /> в <see cref="P:Microsoft.Office.Interop.Outlook._Rules.Item(System.Object)" />. Например, Rules.Item(1) представляет правило с <b>ExecutionOrder</b> , 1, Rules.Item(2) представляет правило с <b>ExecutionOrder</b> , 2 и Rules.Item(Rules.Count) представляет правило с <b>ExecutionOrder</b> , <see cref="P:Microsoft.Office.Interop.Outlook._Rules.Count" />.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLocalRule">
      <MemberSignature Language="C#" Value="public bool IsLocalRule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLocalRule" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.IsLocalRule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLocalRule As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLocalRule { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64269)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64269)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение <b>типа Boolean</b> (<b>bool</b> в C#), которое указывает, если правило выполняет как правило со стороны клиента. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Клиентские правила выполняет, только если запущены Outlook. Если <b>IsLocalRule</b> имеет <b>значение False</b>, правило выполняет как правила на сервере.</para>
          <para>При наличии учетной записи электронной почты Microsoft Exchange Server на сервере правила применяются в сообщения даже в том случае, если у вас нет Outlook при работе. Правила должен иметь значение применяться к сообщениям, когда они будут доставляться в папку "Входящие" на сервере и правила должно иметь возможность выполнить до завершения на сервере. Например правило не может запускать завершения на сервере при действие указывает, что сообщение печать. Если правило не может применяться на сервере, оно применяется при запуске Outlook.</para>
          <para>Если сервер и клиентские правила, содержащимися в семействе правила для хранилища, на сервере правила применяются во-первых, следуют правила клиентской стороны.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.InteropServices.DispId(8450)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает <b>String</b> (<b>строка</b> в C#) представляет имя правила. Для чтения и записи.</summary>
        <value>To be added.</value>
        <remarks><para>
            <b>Имя</b> — это свойство по умолчанию и индексатор для правила в <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> объекта collection. Оно соответствует <b>PidTagRuleMsgName</b> (0x65EC001E).</para>
          <para>Имена правил не являются уникальными среди правил в одном семействе.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public object Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Parent" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Parent { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61441)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский <b>объект</b> заданного объекта. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Родительский <see cref="T:Microsoft.Office.Interop.Outlook.Rule" /> — это объект <see cref="T:Microsoft.Office.Interop.Outlook.Rules" /> объекта.</para>
          <para> </para></remarks>
      </Docs>
    </Member>
    <Member MemberName="RuleType">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.OlRuleType RuleType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype Microsoft.Office.Interop.Outlook.OlRuleType RuleType" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.RuleType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RuleType As OlRuleType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::OlRuleType RuleType { Microsoft::Office::Interop::Outlook::OlRuleType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(64268)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(64268)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.OlRuleType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает константу из <see cref="T:Microsoft.Office.Interop.Outlook.OlRuleType" /> перечисление, указывающее, если правило применяется к сообщениям, которые они отправку и получение. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public Microsoft.Office.Interop.Outlook.NameSpace Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Office.Interop.Outlook.NameSpace Session" />
      <MemberSignature Language="DocId" Value="P:Microsoft.Office.Interop.Outlook._Rule.Session" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Session As NameSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Office::Interop::Outlook::NameSpace ^ Session { Microsoft::Office::Interop::Outlook::NameSpace ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.Office.Interop.Outlook</AssemblyName>
        <AssemblyVersion>15.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.InteropServices.DispId(61451)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Office.Interop.Outlook.NameSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:Microsoft.Office.Interop.Outlook.NameSpace" /> объекта для текущего сеанса. Только для чтения.</summary>
        <value>To be added.</value>
        <remarks><para>Свойство <b>сеанса</b> и <see cref="M:Microsoft.Office.Interop.Outlook._Application.GetNamespace(System.String)" /> взаимозаменяемыми метод для получения объекта <b>пространства имен</b> для текущего сеанса. Члены по своему назначению. Например следующие пары операторов выполнить те же функции.</para>
          <code>Dim objNamespace As Outlook.NameSpace = _
    Application.GetNamespace("MAPI")</code>
          <code>Dim objSession As Outlook.NameSpace = Application.Session</code>
          <code>Outlook.NameSpace objNamespace = 
    Application.GetNamespace("MAPI");</code>
          <code>Outlook.NameSpace objSession = Application.Session;</code>
          <para> </para></remarks>
      </Docs>
    </Member>
  </Members>
</Type>
